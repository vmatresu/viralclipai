# Storage & Media (Cloudflare R2, Rust)

This document explains how video artifacts are stored using the Rust `vclip-storage` crate and Cloudflare R2.

## Overview

Viral Clip AI uses **Cloudflare R2** as the primary object store for:

- Processed clip files (`.mp4`)
- Clip thumbnails (`.jpg`)
- Highlight metadata (`highlights.json`)

R2 is S3-compatible and offers zero egress fees, which is ideal for a video-heavy SaaS fronted by a CDN.

The Rust `vclip-storage` crate encapsulates all R2 interactions.

## Quotas and plans

This document focuses on **where** bytes live (R2 layout and media flows).
For **plan tiers, clip quotas, and per-user storage limits**, see
`plans-and-quotas.md`. That doc explains how much storage and how many clips
each plan is allowed, and how usage is tracked; this doc explains how the
underlying media objects are organized and accessed.

## Configuration

Backend configuration is done via env vars (see `docs/configuration.md` and `r2-setup.md`):

- `R2_ACCOUNT_ID`
- `R2_BUCKET_NAME`
- `R2_ACCESS_KEY_ID`
- `R2_SECRET_ACCESS_KEY`
- `R2_ENDPOINT_URL`
- `R2_REGION` (usually `auto`)
- `R2_PUBLIC_URL` (optional CDN domain)

On startup, the backend initializes an S3 client pointing at the R2 endpoint and may perform a lightweight connectivity check.

## Bucket Layout

Object keys are namespaced per user and per video (`video_id` / `run_id`):

```text
users/{uid}/{video_id}/highlights.json
users/{uid}/{video_id}/clips/clip_XX_YY_title_style.mp4
users/{uid}/{video_id}/clips/clip_XX_YY_title_style.jpg
```

This layout:

- Keeps per-user data isolated
- Makes it easy to purge all data for a user or a single video
- Matches the Firestore metadata structure used by `vclip-firestore`

## Interaction Pattern

The worker and API interact with R2 primarily via `vclip-storage`:

- **Upload**: after a clip is rendered, the worker uploads the `.mp4` and thumbnail
- **Highlights**: after Gemini analysis, the worker writes `highlights.json`
- **Presigned URLs**: the API generates short-lived URLs for clips and thumbnails that the frontend consumes

High-level flow:

1. Worker renders a clip to the local work directory
2. Worker uploads clip and thumbnail to R2 under the keys above
3. Worker updates Firestore metadata with the canonical R2 keys and file sizes
4. API later generates presigned URLs when returning clip metadata to clients

## Security

Recommended practices:

- Keep the R2 bucket **non-public** (no public listing)
- Access objects exclusively via:
  - Presigned URLs generated by the backend
  - Internal services using API keys
- Use different API tokens for dev/staging/prod with minimal permissions
- Store all secrets in env vars / secrets manager, never in source control

## CDN & Public Access

For best performance:

1. Configure a **custom domain** in R2 (e.g. `cdn.yourdomain.com`)
2. Set `R2_PUBLIC_URL` to that domain
3. Serve presigned URLs (or public keys) via the CDN domain

Example public URL:

```text
https://cdn.yourdomain.com/users/{uid}/{video_id}/clips/clip_01_01_title_split.mp4
```

## Relationship with Firestore

The Firestore layer stores metadata that references R2 keys:

- Video docs contain `highlights_json_key`
- Clip docs contain `r2_key` and optional `thumbnail_r2_key`

The API uses Firestore to list/query clips, then R2 to generate URLs. This avoids slow `ListObjects` calls and keeps metadata queries fast. See `docs/video-processing-pipeline.md` for more details.

## Troubleshooting

- **"Video is still being processed"** – `highlights.json` not yet written to R2; wait for worker completion
- **Clips missing after success** – verify worker logs and R2 upload status
- **Permission errors** – check R2 API token scopes and env vars

For R2 credentials and endpoint details, see `r2-setup.md`.
