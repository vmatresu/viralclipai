/**
 * Watch Page Transcript Fetcher
 *
 * Fetches transcript data directly from the YouTube watch page and the
 * youtubei transcript endpoint, without youtubei.js.
 */

import https from "node:https";
import type {
    AdChapter,
    CaptionTrack,
    PageData,
    TranscriptApiResponse,
    TranscriptLine,
    TranscriptSegmentItem,
    WatchPageSubtitleResult,
    WatchPageVideoMetadata,
} from "./watch-page-types.js";

const REQUEST_TIMEOUT = 30_000;

// Anti-ban: Small delay between requests to avoid burst patterns
const INTER_REQUEST_DELAY_MS = 150;

/**
 * Delay execution for anti-ban purposes
 */
function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// TODO: These versions may need periodic updates if YouTube starts rejecting old clients
const WEB_USER_AGENT =
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36";
const DEFAULT_CLIENT_VERSION = "2.20251201.01.00";

/**
 * Encodes a number as a protobuf varint
 * Handles lengths > 127 correctly (multi-byte encoding)
 */
function encodeVarint(value: number): number[] {
  const result: number[] = [];
  while (value > 127) {
    result.push((value & 0x7f) | 0x80);
    value >>>= 7;
  }
  result.push(value & 0x7f);
  return result;
}

/**
 * Builds the protobuf-encoded params for the transcript API
 */
function buildParams(videoId: string, lang: string = "en"): string {
  // Field 1: nested message with video ID
  const videoIdBytes = Buffer.from(videoId, "utf8");
  const videoIdLength = encodeVarint(videoIdBytes.length);
  const field1Content = Buffer.concat([
    Buffer.from([0x0a]), // Field 1, wire type 2 (length-delimited)
    Buffer.from(videoIdLength),
    videoIdBytes,
  ]);

  // Wrap in outer field 1
  const field1Wrapper = Buffer.concat([
    Buffer.from([0x0a]), // Field 1
    Buffer.from(encodeVarint(field1Content.length)),
    field1Content,
  ]);

  // Field 2: language
  const langBytes = Buffer.from(lang, "utf8");
  const langLength = encodeVarint(langBytes.length);
  const field2 = Buffer.concat([
    Buffer.from([0x12]), // Field 2, wire type 2
    Buffer.from(langLength),
    langBytes,
  ]);

  // Field 3: constant
  const field3 = Buffer.from([0x1a, 0x00]);

  // Combine all fields
  const innerPayload = Buffer.concat([field1Wrapper, field2, field3]);

  // Wrap in outer message
  const outerPayload = Buffer.concat([
    Buffer.from([0x0a]), // Field 1
    Buffer.from(encodeVarint(innerPayload.length)),
    innerPayload,
  ]);

  return Buffer.from(outerPayload).toString("base64url");
}

/**
 * Makes an HTTPS request and returns the response body
 * Includes timeout and HTTP status code validation
 */
function httpsRequest(
  options: https.RequestOptions,
  data?: string
): Promise<string> {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let body = "";
      res.on("data", (chunk) => {
        body += chunk;
      });
      res.on("end", () => {
        if (res.statusCode && res.statusCode >= 400) {
          reject(
            new Error(`HTTP ${res.statusCode}: ${body.slice(0, 200)}`)
          );
        } else {
          resolve(body);
        }
      });
    });

    req.on("error", reject);
    req.setTimeout(REQUEST_TIMEOUT, () => {
      req.destroy();
      reject(new Error("Request timeout"));
    });

    if (data) {
      req.write(data);
    }
    req.end();
  });
}

/**
 * Fetches the YouTube video page and extracts visitor data and client version
 */
async function getPageData(videoId: string): Promise<PageData> {
  const html = await httpsRequest({
    hostname: "www.youtube.com",
    path: `/watch?v=${videoId}`,
    method: "GET",
    headers: {
      "User-Agent": WEB_USER_AGENT,
      Accept:
        "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
      "Accept-Language": "en-US,en;q=0.9",
    },
  });

  // Extract visitor data
  const visitorDataMatch = html.match(/"visitorData":"([^"]+)"/);
  const visitorData = visitorDataMatch?.[1] || "";

  // Extract client version
  const clientVersionMatch = html.match(/"clientVersion":"([^"]+)"/);
  const clientVersion = clientVersionMatch?.[1] || DEFAULT_CLIENT_VERSION;

  // Extract available languages from captionTracks
  const availableLanguages: CaptionTrack[] = [];
  const captionTracksMatch = html.match(/"captionTracks":\s*(\[[^\]]+\])/);
  if (captionTracksMatch) {
    try {
      const tracks = JSON.parse(captionTracksMatch[1]);
      for (const track of tracks) {
        availableLanguages.push({
          languageCode: track.languageCode || "",
          name: track.name?.simpleText || track.languageCode || "",
          isAutoGenerated: track.kind === "asr",
        });
      }
    } catch {
      // Ignore parse errors
    }
  }

  // Extract ad chapters (sponsored segments)
  const adChapters: AdChapter[] = [];
  const chaptersMatch = html.match(/"decoratedPlayerBarRenderer"[^}]+?"chapters":\s*(\[[^\]]*\])/);
  if (chaptersMatch) {
    try {
      const chapters = JSON.parse(chaptersMatch[1]);
      for (const chapter of chapters) {
        const renderer = chapter?.chapterRenderer;
        if (renderer?.title?.simpleText?.toLowerCase().includes("sponsor")) {
          adChapters.push({
            title: renderer.title.simpleText,
            startMs: Number(renderer.timeRangeStartMillis) || 0,
            endMs:
              Number(renderer.timeRangeStartMillis) +
              Number(renderer.lengthMs) ||
              0,
          });
        }
      }
    } catch {
      // Ignore parse errors
    }
  }

  // Extract video metadata
  const titleMatch = html.match(/<title>([^<]+)<\/title>/);
  const authorMatch = html.match(/"ownerChannelName":"([^"]+)"/);
  const subscriberMatch = html.match(/"subscriberCountText":\{"simpleText":"([^"]+)"\}/);
  const viewCountMatch = html.match(/"viewCount":"(\d+)"/);
  const publishDateMatch = html.match(/"publishDate":"([^"]+)"/);

  const metadata: WatchPageVideoMetadata = {
    title: titleMatch?.[1]?.replace(" - YouTube", "").trim() || "",
    author: authorMatch?.[1] || "",
    subscriberCount: subscriberMatch?.[1] || "",
    viewCount: viewCountMatch?.[1] || "",
    publishDate: publishDateMatch?.[1] || "",
  };

  return {
    visitorData,
    clientVersion,
    availableLanguages,
    adChapters,
    metadata,
  };
}

/**
 * Fetches transcript using the YouTube internal API
 * If the requested language is not available and enableFallback is true,
 * it will try English first, then fall back to the first available language.
 */
export async function getSubtitles(options: {
  videoID: string;
  lang?: string;
  enableFallback?: boolean;
}): Promise<WatchPageSubtitleResult> {
  const { videoID, lang = "en", enableFallback = true } = options;

  // Step 1: Get page data (visitor data, available languages, etc.)
  const pageData = await getPageData(videoID);

  // Add delay between requests
  await delay(INTER_REQUEST_DELAY_MS);

  // Determine which language to request
  let targetLang = lang;
  const hasRequestedLang = pageData.availableLanguages.some(
    (l) => l.languageCode === lang
  );

  if (!hasRequestedLang && enableFallback) {
    // Try English first
    const hasEnglish = pageData.availableLanguages.some(
      (l) => l.languageCode.startsWith("en")
    );
    if (hasEnglish) {
      targetLang = "en";
    } else if (pageData.availableLanguages.length > 0) {
      // Fall back to first available
      targetLang = pageData.availableLanguages[0].languageCode;
    }
  }

  // Step 2: Build and send transcript request
  const params = buildParams(videoID, targetLang);

  const requestBody = JSON.stringify({
    context: {
      client: {
        hl: "en",
        gl: "US",
        clientName: "WEB",
        clientVersion: pageData.clientVersion,
        userAgent: WEB_USER_AGENT,
        visitorData: pageData.visitorData,
      },
    },
    params,
  });

  const response = await httpsRequest(
    {
      hostname: "www.youtube.com",
      path: "/youtubei/v1/get_transcript?prettyPrint=false",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "User-Agent": WEB_USER_AGENT,
        "X-YouTube-Client-Name": "1",
        "X-YouTube-Client-Version": pageData.clientVersion,
        Origin: "https://www.youtube.com",
        Referer: `https://www.youtube.com/watch?v=${videoID}`,
      },
    },
    requestBody
  );

  const json: TranscriptApiResponse = JSON.parse(response);

  if (json.error) {
    throw new Error(json.error.message || "YouTube API error");
  }

  // Extract transcript segments from response
  let segments: TranscriptSegmentItem[] = [];

  // Try new response format first (elementsCommand)
  for (const action of json.actions || []) {
    const newSegments =
      action.elementsCommand?.transformEntityCommand?.arguments
        ?.transformTranscriptSegmentListArguments?.overwrite?.initialSegments;
    if (newSegments?.length) {
      segments = newSegments;
      break;
    }

    // Try old response format (updateEngagementPanelAction)
    const oldSegments =
      action.updateEngagementPanelAction?.content?.transcriptRenderer?.content
        ?.transcriptSearchPanelRenderer?.body?.transcriptSegmentListRenderer
        ?.initialSegments;
    if (oldSegments?.length) {
      segments = oldSegments;
      break;
    }
  }

  if (segments.length === 0) {
    throw new Error("No transcript segments found in response");
  }

  // Parse segments into lines
  const lines: TranscriptLine[] = [];
  for (const segment of segments) {
    const renderer = segment.transcriptSegmentRenderer;
    if (!renderer) continue;

    // Get text from snippet
    let text = "";
    if (renderer.snippet?.runs) {
      text = renderer.snippet.runs.map((r) => r.text || "").join("");
    } else if (renderer.snippet?.elementsAttributedString?.content) {
      text = renderer.snippet.elementsAttributedString.content;
    }

    if (!text) continue;

    const startMs = Number(renderer.startMs) || 0;
    const endMs = Number(renderer.endMs) || startMs;

    lines.push({
      text: text.trim(),
      start: startMs / 1000,
      dur: (endMs - startMs) / 1000,
    });
  }

  if (lines.length === 0) {
    throw new Error("No transcript lines parsed");
  }

  return {
    lines,
    requestedLang: lang,
    actualLang: targetLang,
    availableLanguages: pageData.availableLanguages,
    adChapters: pageData.adChapters,
    metadata: pageData.metadata,
  };
}
