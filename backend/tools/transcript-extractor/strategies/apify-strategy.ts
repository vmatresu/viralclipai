/**
 * Apify YouTube Scraper Transcript Extraction Strategy
 *
 * Final fallback strategy using the Apify YouTube Scraper API.
 * Provides reliable subtitle extraction when other methods fail.
 *
 * @see https://apify.com/streamers/youtube-scraper
 */

import {
    STRATEGY_TIMEOUTS,
    TranscriptErrorType,
    TranscriptOptions,
    TranscriptOutcome,
    VideoMetadata,
} from "../types/index.js";
import { withTimeout } from "../utils/circuit-breaker.js";
import { Config } from "../utils/config.js";
import { logger } from "../utils/logger.js";
import { parseSrtToTranscript } from "../utils/srt-parser.js";
import {
    APIFY_SUPPORTED_LANGUAGES,
    ApifySubtitle,
    ApifySupportedLanguage,
    ApifyVideoResult,
} from "./apify-types.js";
import { classifyTranscriptError, TranscriptStrategy } from "./base.js";

/** Minimum transcript length to consider valid */
const MIN_TRANSCRIPT_LENGTH = 10;

/** YouTube video ID regex pattern */
const VIDEO_ID_PATTERN = /^[A-Za-z0-9_-]{11}$/;

function isApifySupportedLanguage(
  value: string
): value is ApifySupportedLanguage {
  return APIFY_SUPPORTED_LANGUAGES.includes(value as ApifySupportedLanguage);
}

/**
 * Strategy for extracting transcripts using Apify YouTube Scraper API
 */
export class ApifyScraperStrategy extends TranscriptStrategy {
  constructor() {
    super({
      name: "apify",
      timeoutMs: STRATEGY_TIMEOUTS.apify,
      enabled: true,
      priority: 5, // Lowest priority (last resort)
    });
  }

  async isAvailable(): Promise<boolean> {
    return Boolean(Config.apifyToken);
  }

  async extract(
    videoId: string,
    options: TranscriptOptions
  ): Promise<TranscriptOutcome> {
    const startTime = Date.now();
    const timeoutMs = options.timeoutMs ?? this.config.timeoutMs;
    const includeTimestamps = options.includeTimestamps ?? true;

    // Validate video ID
    if (!this.isValidVideoId(videoId)) {
      return this.errorResult(
        `Invalid video ID: ${videoId}`,
        TranscriptErrorType.UNKNOWN
      );
    }

    try {
      logger.info(
        { videoId, strategy: this.config.name },
        "Starting extraction"
      );

      const preferredLanguages = options.preferredLanguages || ["en", "*"];

      // Fetch from Apify
      const results = await this.fetchFromApify(
        videoId,
        preferredLanguages,
        timeoutMs
      );

      if (results.length === 0) {
        return this.errorResult(
          "No video data returned from Apify",
          TranscriptErrorType.VIDEO_UNAVAILABLE
        );
      }

      const video = results[0];

      // Check for subtitles
      if (!video.subtitles || video.subtitles.length === 0) {
        return this.errorResult(
          "No captions available for this video",
          TranscriptErrorType.NO_CAPTIONS
        );
      }

      // Select best subtitle track
      const bestSubtitle = this.selectBestSubtitle(
        video.subtitles,
        preferredLanguages
      );

      if (!bestSubtitle || !bestSubtitle.srt) {
        return this.errorResult(
          "No suitable subtitle track found",
          TranscriptErrorType.NO_CAPTIONS
        );
      }

      // Parse SRT to transcript
      const transcript = parseSrtToTranscript(bestSubtitle.srt, includeTimestamps);

      if (transcript.length < MIN_TRANSCRIPT_LENGTH) {
        return this.errorResult(
          "Transcript too short or empty",
          TranscriptErrorType.NO_CAPTIONS
        );
      }

      const durationMs = Date.now() - startTime;
      logger.info(
        {
          videoId,
          strategy: this.config.name,
          durationMs,
          length: transcript.length,
          language: bestSubtitle.language,
        },
        "Extraction successful"
      );

      return {
        success: true,
        transcript,
        source: "apify",
        language: bestSubtitle.language,
        isAutoGenerated: bestSubtitle.type === "auto_generated",
        metadata: this.extractMetadata(video),
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      const errorType = classifyTranscriptError(errorMessage);

      logger.warn(
        { videoId, strategy: this.config.name, error: errorMessage, errorType },
        "Extraction failed"
      );

      return {
        success: false,
        error: errorMessage,
        errorType,
        source: "apify",
      };
    }
  }

  private isValidVideoId(videoId: string): boolean {
    return VIDEO_ID_PATTERN.test(videoId);
  }

  private errorResult(error: string, errorType: TranscriptErrorType): TranscriptOutcome {
    return { success: false, error, errorType, source: "apify" };
  }

  private async fetchFromApify(
    videoId: string,
    preferredLanguages: string[],
    timeoutMs: number
  ): Promise<ApifyVideoResult[]> {
    const token = Config.apifyToken;
    if (!token) {
      throw new Error("Apify API token not configured");
    }

    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const language = this.resolveLanguage(preferredLanguages);

    const body = JSON.stringify({
      downloadSubtitles: true,
      startUrls: [{ url: videoUrl }],
      subtitlesFormat: "srt",
      subtitlesLanguage: language,
      preferAutoGeneratedSubtitles: true,
      maxResults: 1,
      maxResultsShorts: 0,
      maxResultStreams: 0,
    });

    const apiUrl = new URL(
      "https://api.apify.com/v2/acts/streamers~youtube-scraper/run-sync-get-dataset-items"
    );
    apiUrl.searchParams.set("token", token);

    logger.debug(
      { url: this.maskToken(apiUrl), videoId },
      "Calling Apify API"
    );

    const response = await withTimeout(
      fetch(apiUrl.toString(), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body,
      }),
      timeoutMs,
      "Apify API request"
    );

    if (!response.ok) {
      throw new Error(`Apify API error: ${response.status} ${response.statusText}`);
    }

    return (await response.json()) as ApifyVideoResult[];
  }

  private maskToken(url: URL): string {
    const masked = new URL(url.toString());
    masked.searchParams.set("token", "***");
    return masked.toString();
  }

  private resolveLanguage(preferredLanguages: string[]): string {
    for (const lang of preferredLanguages) {
      if (lang === "*") return "any";
      if (isApifySupportedLanguage(lang)) return lang;
    }
    return "any";
  }

  private selectBestSubtitle(
    subtitles: ApifySubtitle[],
    preferredLanguages: string[]
  ): ApifySubtitle | null {
    if (subtitles.length === 0) return null;

    // Sort by preference
    const sorted = [...subtitles].sort((a, b) => {
      // Prefer manual over auto-generated
      const aAuto = a.type === "auto_generated" ? 1 : 0;
      const bAuto = b.type === "auto_generated" ? 1 : 0;
      if (aAuto !== bAuto) return aAuto - bAuto;

      // Prefer earlier in language preference list
      const aScore = this.getLanguageScore(a.language, preferredLanguages);
      const bScore = this.getLanguageScore(b.language, preferredLanguages);

      return aScore - bScore;
    });

    return sorted[0];
  }

  private getLanguageScore(language: string, preferredLanguages: string[]): number {
    for (let i = 0; i < preferredLanguages.length; i++) {
      const pref = preferredLanguages[i];
      if (pref === "*") return i;
      if (language.startsWith(pref)) return i;
    }
    return 999;
  }

  private extractMetadata(video: ApifyVideoResult): VideoMetadata {
    return {
      title: video.title,
      description: video.text,
      thumbnailUrl: video.thumbnailUrl,
      viewCount: video.viewCount,
      publishedAt: video.date,
      likes: video.likes,
      channelName: video.channelName,
      channelUrl: video.channelUrl,
      channelId: video.channelId,
      subscriberCount: video.numberOfSubscribers,
      duration: video.duration,
      commentsCount: video.commentsCount,
    };
  }
}
