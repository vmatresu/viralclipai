/**
 * Watch Page Transcript Extraction Strategy
 *
 * Uses direct HTTPS requests against the YouTube watch page and youtubei
 * transcript endpoint (without youtubei.js) to fetch transcripts and basic
 * metadata. Serves as a lightweight primary strategy.
 */

import {
    STRATEGY_TIMEOUTS,
    TranscriptOptions,
    TranscriptOutcome,
    type TranscriptSegment,
} from "../types/index.js";
import { withTimeout } from "../utils/circuit-breaker.js";
import { logger } from "../utils/logger.js";
import {
    deduplicateSegments,
    segmentsToTranscript,
} from "../utils/vtt-parser.js";
import { classifyTranscriptError, TranscriptStrategy } from "./base.js";
import { getSubtitles } from "./watch-page-client.js";
import type { WatchPageSubtitleResult } from "./watch-page-types.js";

export class WatchPageStrategy extends TranscriptStrategy {
  constructor() {
    super({
      name: "watch-page",
      timeoutMs: STRATEGY_TIMEOUTS.watchPage,
      enabled: true,
      priority: 1, // Highest priority - lightweight
    });
  }

  async isAvailable(): Promise<boolean> {
    return true; // Always available (uses native HTTPS)
  }

  async extract(
    videoId: string,
    options: TranscriptOptions
  ): Promise<TranscriptOutcome> {
    const startTime = Date.now();
    const timeoutMs = options.timeoutMs ?? this.config.timeoutMs;
    const includeTimestamps = options.includeTimestamps ?? true;

    try {
      logger.info(
        { videoId, strategy: this.config.name },
        "Starting extraction"
      );

      const subtitleResult: WatchPageSubtitleResult = await withTimeout(
        getSubtitles({
          videoID: videoId,
          lang: options.preferredLanguages?.[0],
        }),
        timeoutMs,
        "Fetch watch page transcript"
      );

      const segments: TranscriptSegment[] = subtitleResult.lines.map((line) => {
        const startMs = Math.round(line.start * 1000);
        const endMs = Math.round((line.start + line.dur) * 1000);
        return { startMs, endMs, text: line.text };
      });

      const deduplicated = deduplicateSegments(segments);
      const transcript = segmentsToTranscript(deduplicated, includeTimestamps);

      const durationMs = Date.now() - startTime;
      logger.info(
        {
          videoId,
          strategy: this.config.name,
          durationMs,
          length: transcript.length,
          language: subtitleResult.actualLang,
        },
        "Extraction successful"
      );

      return {
        success: true,
        transcript,
        source: "watch-page",
        segmentCount: deduplicated.length,
        language: subtitleResult.actualLang,
        isAutoGenerated: subtitleResult.availableLanguages.find(
          (track) => track.languageCode === subtitleResult.actualLang
        )?.isAutoGenerated,
        metadata: {
          title: subtitleResult.metadata.title,
          channelName: subtitleResult.metadata.author,
          publishedAt: subtitleResult.metadata.publishDate,
          subscriberCount:
            Number.parseInt(
              subtitleResult.metadata.subscriberCount.replace(/[^\d]/g, ""),
              10
            ) || undefined,
        },
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      const errorType = classifyTranscriptError(errorMessage);

      logger.warn(
        { videoId, strategy: this.config.name, error: errorMessage, errorType },
        "Extraction failed"
      );

      return {
        success: false,
        error: errorMessage,
        errorType,
        source: "watch-page",
      };
    }
  }
}
